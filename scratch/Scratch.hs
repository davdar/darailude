-- infix  9 ?
-- infixl 9 #
-- infixl 9 #!
-- infixl 9 <@>
-- infixl 9 *@
-- infixl 9 ^@
-- infixl 9 ^*@
-- infixr 9 *.
-- infixr 9 ^.
-- infixr 9 .^
-- infixr 9 ^^.
-- infixr 9 ^.:
-- infixr 9 ^*.
-- infixr 9 <.>
-- infixr 9 .:
-- infixr 9 ..:
-- infixr 9 :.:
-- 
-- infix  7 /
-- infix  7 //
-- infixr 7 *
-- infixr 7 <*>
-- infixr 7 /\
-- 
-- infix  6 -
-- infix  6 \\
-- infixr 6 +
-- infixr 6 ++
-- infixr 6 :+:
-- infixr 6 <+>
-- infixr 6 \/
-- 
-- infix  4 ‚äë
-- infix  4 ‚äè
-- 
-- infixl 1 >>=
-- infixl 1 >>
-- infixr 1 ~>
-- 
-- infixr 0 *$
-- infixr 0 ^$
-- infixr 0 ^*$
-- infixr 0 <$>
-- 


-- class (TruncateDivisible a,ToInteger a,FromInteger a,ToInt a,FromInt a,ToRational a,ToDouble a) => Integral a
-- class (Divisible a,ToRational a,FromRational a,ToDouble a,FromDouble a,FromInteger a,FromInt a) => Fractional a
-- 
-- -- PartialOrder {{{
-- 
-- data POrdering = PEQ | PLT | PGT | PUN
-- 
-- -- Minimal definition: pcompare OR (‚äë)
-- class PartialOrder a where
--   pcompare :: a -> a -> POrdering
--   pcompare x y = case (x ‚äë y, y ‚äë x) of
--     (True , True ) -> PEQ
--     (True , False) -> PLT
--     (False, True ) -> PGT
--     (False, False) -> PUN
--   (‚äë) :: a -> a -> Bool
--   x ‚äë y = case pcompare x y of
--     PLT -> True
--     PEQ -> True
--     _   -> False
--   (‚äè) :: a -> a -> Bool
--   x ‚äè y = case pcompare x y of
--     PLT -> True
--     _ -> False
-- 
-- (‚ãö) :: (Ord a)          => a -> a -> Ordering  ; (‚ãö) = compare
-- (‚ãà) :: (PartialOrder a) => a -> a -> POrdering ; (‚ãà) = pcompare
-- (‚äí) :: (PartialOrder a) => a -> a -> Bool      ; (‚äí) = flip (‚äë)
-- (‚äê) :: (PartialOrder a) => a -> a -> Bool      ; (‚äê) = flip (‚äè)
-- 
-- fromOrdering :: Ordering -> POrdering
-- fromOrdering EQ = PEQ
-- fromOrdering LT = PLT
-- fromOrdering GT = PGT
-- 
-- discreteOrder :: (Eq a) => a -> a -> POrdering
-- discreteOrder x y = if x == y then PEQ else PUN
-- 
-- -- TODO: rename this and make findMax not be predicated on `p`
-- findMax :: (Iterable a t, PartialOrder b) => (a -> b) -> a -> t -> a
-- findMax p i0 = iterFrom i0 $ \ a i -> if p a ‚äê p i then a else i
-- 
-- findMaxFrom :: (Iterable a t, PartialOrder b) => a -> (a -> b) -> t -> a
-- findMaxFrom = flip findMax
-- 
-- findMax' :: (Iterable a t, PartialOrder a, JoinLattice a) => t -> a
-- findMax' = findMax id bot
-- 
-- 
-- -- }}}
-- class Unit2       (t :: (* -> *) -> (* -> *)) where unit2   :: m                ~> t m
-- class Join2       (t :: (* -> *) -> (* -> *)) where join2   :: t (t m)          ~> t m
-- class Functor2    (t :: (* -> *) -> (* -> *)) where map2    :: (m ~> n)         -> (t m ~> t n)
-- class IsoFunctor2 (t :: (* -> *) -> (* -> *)) where isoMap2 :: (m ~> n, n ~> m) -> (t m ~> t n)

-- class MonadUnit2       (t :: (* -> *) -> (* -> *)) where munit2   :: (Monad m)          => m                ~> t m
-- class MonadJoin2       (t :: (* -> *) -> (* -> *)) where mjoin2   :: (Monad m)          => t (t m)          ~> t m
-- class MonadFunctor2    (t :: (* -> *) -> (* -> *)) where mmap2    :: (Monad m, Monad n) => (m ~> n)         -> (t m ~> t n)
-- class MonadIsoFunctor2 (t :: (* -> *) -> (* -> *)) where misoMap2 :: (Monad m, Monad n) => (m ~> n, n ~> m) -> (t m ~> t n)

-- newtype RWST r o s m a = RWST { runRWST :: ReaderT r (WriterT o (StateT s m)) a }
-- 
-- class (MonadReader r m,MonadWriter o m,MonadState s m) => MonadRWS r o s m where
--   rwsE :: RWST r o s m ‚Üù m
--   rwsI :: m ‚Üù RWST r o s m
-----------------
-- Applicative --
-----------------
-- instance Unit ((‚®Ñ) a) where unit = Inr
-- class Unit (t ‚à∑ ‚òÖ ‚Üí ‚òÖ) where unit ‚à∑ a ‚Üí t a
-- class Applicative (t ‚à∑ ‚òÖ ‚Üí ‚òÖ) where {pure ‚à∑ a ‚Üí t a;(<‚ãÖ>) ‚à∑ t (a ‚Üí b) ‚Üí t a ‚Üí t b}
-- class Product (t ‚à∑ ‚òÖ ‚Üí ‚òÖ) where (<*>) ‚à∑ t a ‚Üí t b ‚Üí t (a,b)
-- (<$>) ‚à∑ (Applicative t) ‚áí t (a ‚Üí b) ‚Üí t a ‚Üí t b 
-- (<$>) = (<‚ãÖ>)

-- apair ‚à∑ (Applicative t) ‚áí t a ‚Üí t b ‚Üí t (a,b) 
-- apair aA bA = pure (,) <‚ãÖ> aA <‚ãÖ> bA

-- instance Product ((‚®Ñ) a) where (<*>) = mpair
-- instance Applicative ((‚®Ñ) a) where {pure = unit;(<‚ãÖ>) = mapply}
-- instance Unit Maybe where unit = return
-- instance Applicative Maybe where {pure = return;(<‚ãÖ>) = mapply}
-- instance Product Maybe where (<*>) = mpair
-- instance Unit IO where unit = return
-- instance Applicative IO where {pure = return;(<‚ãÖ>) = mapply}
-- instance Product IO where (<*>) = mpair
-- instance Unit Q where unit = return
-- instance Applicative Q where {pure = return;(<‚ãÖ>) = mapply}
-- instance Product Q where (<*>) = mpair
---------------------------------------
-- Monads -----------------------------
---------------------------------------
-- 
-- instance Unit ID where unit = ID
-- instance Product ID where aM <*> bM = ID $ (runID aM, runID bM)
-- instance Applicative ID where fM <‚ãÖ> aM = ID $ runID fM $ runID aM
-- instance (Unit m) ‚áí Unit (MaybeT m) where
--   unit = MaybeT ‚àò unit ‚àò Just
-- instance (Functor m, Product m) ‚áí Product (MaybeT m) where
--   aM1 <*> aM2 = MaybeT $ uncurry ff ^$ runMaybeT aM1 <*> runMaybeT aM2
--     where
--       ff Nothing _ = Nothing
--       ff _ Nothing = Nothing
--       ff (Just a1) (Just a2) = Just (a1, a2)
-- instance (Functor m, Applicative m) ‚áí Applicative (MaybeT m) where
--   fM <‚ãÖ> aM = MaybeT $ ff ^‚ãÖ runMaybeT fM <$> runMaybeT aM
--     where
--       ff Nothing _ = Nothing
--       ff _ Nothing = Nothing
--       ff (Just f) (Just a) = Just $ f a
-- instance (Unit m) ‚áí Unit (ErrorT e m) where
--   unit a = ErrorT $ unit $ Inr a
-- instance (Functor m, Product m) ‚áí Product (ErrorT e m) where
--   aM1 <*> aM2 = ErrorT $ ff ^$ runErrorT aM1 <*> runErrorT aM2
--     where
--       ff (Inl e, _) = Inl e
--       ff (_, Inl e) = Inl e
--       ff (Inr a, Inr b) = Inr (a, b)
-- instance (Functor m, Applicative m) ‚áí Applicative (ErrorT e m) where
--   fM <‚ãÖ> aM = ErrorT $ ff ^‚ãÖ runErrorT fM <$> runErrorT aM
--     where
--       ff (Inl e) _ = Inl e
--       ff _ (Inl e) = Inl e
--       ff (Inr f) (Inr a) = Inr $ f a
-- instance (Unit m) ‚áí Unit (ReaderT r m) where
--   unit = ReaderT ‚àò const ‚àò unit
-- instance (Product m) ‚áí Product (ReaderT r m) where
--   aM1 <*> aM2 = ReaderT $ \ r ‚Üí
--     runReaderTWith r aM1 <*> runReaderTWith r aM2
-- instance (Applicative m) ‚áí Applicative (ReaderT r m) where
--   fM <‚ãÖ> aM = ReaderT $ \ r ‚Üí
--     runReaderTWith r fM <‚ãÖ> runReaderTWith r aM
-- instance (Unit m, Monoid o) ‚áí Unit (WriterT o m) where unit = WriterT ‚àò unit ‚àò (null,)
-- instance (Functor m, Product m, Monoid o) ‚áí Product (WriterT o m) where
--   aM1 <*> aM2 = WriterT $ ff ^$ runWriterT aM1 <*> runWriterT aM2
--     where
--       ff ((o1, a1), (o2, a2)) = (o1 ++ o2, (a1, a2))
-- instance (Functor m, Applicative m, Monoid o) ‚áí Applicative (WriterT o m) where
--   fM <‚ãÖ> aM = WriterT $ ff2 ^$ ff1 ^‚ãÖ runWriterT fM <$> runWriterT aM
--     where
--       ff1 (o, f) = mapSnd ((o,) ‚àò f)
--       ff2 (o2, (o1, a)) = (o1 ++ o2, a)
-- instance (Unit m) ‚áí Unit (StateT s m) where unit x = StateT $ \ s ‚Üí unit (s, x)
-- instance (Monad m) ‚áí Product (StateT s m) where (<*>) = mpair
-- instance (Monad m) ‚áí Applicative (StateT s m) where (<‚ãÖ>) = mapply
-- runRWST ‚à∑ (Functor m) ‚áí r ‚Üí s ‚Üí RWST r o s m a ‚Üí m (s, o, a)
-- runRWST r0 s0 = ff ^‚àò runStateTWith s0 ‚àò runWriterT ‚àò runReaderT r0 ‚àò unRWST
--   where
--     ff (s, (o, a)) = (s, o, a)
-- rwsCommute ‚à∑ (Monad m, Monoid o1, Monoid o2) ‚áí RWST r1 o1 s1 (RWST r2 o2 s2 m) ‚Üù RWST r2 o2 s2 (RWST r1 o1 s1 m)
-- rwsCommute =
--   RWST
--   ‚àò fmap (fmap rwsStateCommute ‚àò rwsWriterCommute)
--   ‚àò rwsReaderCommute
--   ‚àò mmap2 unRWST
-- 
-- deriving instance (Unit m, Monoid o) ‚áí Unit (RWST r o s m)
-- deriving instance (Functor m) ‚áí Functor (RWST r o s m)
-- deriving instance (Monad m, Monoid o) ‚áí Product (RWST r o s m)
-- deriving instance (Monad m, Monoid o) ‚áí Applicative (RWST r o s m)
-- deriving instance (Monad m, Monoid o) ‚áí Bind (RWST r o s m)
-- deriving instance (Monad m, Monoid o) ‚áí Monad (RWST r o s m)
-- instance (Monoid o) ‚áí MonadUnit2 (RWST r o s) where
--   munit2 = RWST ‚àò funit ‚àò funit ‚àò funit
-- instance (Monoid o) ‚áí MonadJoin2 (RWST r o s) where
--   mjoin2 =
--     RWST
--     ‚àò fjoin
--     ‚àò fmap (fmap fjoin ‚àò writerReaderCommute)
--     ‚àò fmap (fmap (fmap (fmap fjoin ‚àò stateWriterCommute) ‚àò stateReaderCommute))
--     ‚àò unRWST ‚àò mmap2 unRWST
-- instance (Monoid o) ‚áí MonadFunctor2 (RWST r o s) where
--   mmap2 f = RWST ‚àò fmap (fmap (fmap f)) ‚àò unRWST
-- 
-- deriving instance (Monad m, Monoid o) ‚áí MonadReader r (RWST r o s m)
-- deriving instance (Monad m, Monoid o) ‚áí MonadWriter o (RWST r o s m)
-- deriving instance (Monad m, Monoid o) ‚áí MonadState s (RWST r o s m)
-- instance (Monad m, Monoid o) ‚áí MonadRWS r o s (RWST r o s m) where
--   rwsI ‚à∑ RWST r o s m ‚Üù RWST r o s (RWST r o s m)
--   rwsI = rwsCommute ‚àò munit2
--   rwsE ‚à∑ RWST r o s (RWST r o s m) ‚Üù RWST r o s m
--   rwsE = mjoin2 ‚àò rwsCommute
-- 
-- deriving instance (MonadZero m, Monoid o) ‚áí MonadZero (RWST r o s m)
-- deriving instance (Functor m, MonadMaybe m, Monoid o) ‚áí MonadMaybe (RWST r o s m)

-- instance (Unit m) ‚áí Unit (ListT m) where
--   unit = ListT ‚àò unit ‚àò list ‚àò single
-- instance (Monad m, Functorial Monoid m) ‚áí Product (ListT m) where
--   (<*>) = mpair
-- instance (Monad m, Functorial Monoid m) ‚áí Applicative (ListT m) where
--   (<‚ãÖ>) = mapply
-- newtype SetT m a = SetT { unSetT ‚à∑ m (Set a) }
-- mapSetT ‚à∑ (m (Set a) ‚Üí m (Set b)) ‚Üí SetT m a ‚Üí SetT m b
-- mapSetT f = SetT ‚àò f ‚àò unSetT
-- 
-- setCommute ‚à∑ (Functor m) ‚áí SetT (SetT m) ‚Üù SetT (SetT m)
-- setCommute = SetT ‚àò SetT ‚àò setTranspose ^‚àò unSetT ‚àò unSetT
-- 
-- instance (Functor m, Product m) ‚áí Product (SetT m) where
--   (<*>) ‚à∑ forall a b. SetT m a ‚Üí SetT m b ‚Üí SetT m (a, b)
--   aM1 <*> aM2 = SetT $ uncurry (<*>) ^$ unSetT aM1 <*> unSetT aM2
-- instance (Functorial JoinLattice m, Monad m) ‚áí Bind (SetT m) where
--   aM ‚â´= k = SetT $ do
--     aC ‚Üê unSetT aM
--     unSetT $ msum $ k ^$ toList aC
-- instance (Functorial JoinLattice m) ‚áí MonadZero (SetT m) where
--   mzero ‚à∑ forall a. SetT m a
--   mzero = 
--     with (functorial ‚à∑ W (JoinLattice (m (Set a)))) $
--     SetT bot
-- instance (Functorial JoinLattice m) ‚áí MonadJoin (SetT m) where
--   (<‚äî>) ‚à∑ forall a. SetT m a ‚Üí SetT m a ‚Üí SetT m a
--   aM1 <‚äî> aM2 =
--     with (functorial ‚à∑ W (JoinLattice (m (Set a)))) $
--     SetT $ unSetT aM1 ‚äî unSetT aM2

-- instance Unit (ContT r m) where
--   unit a = ContT $ \ k ‚Üí k a
-- instance Applicative (ContT r m) where
--   pure = return
--   (<‚ãÖ>) = mapply
-- instance Product (ContT r m) where
--   (<*>) = mpair
-- instance (Morphism3 (k r) (ContFun r)) ‚áí Unit (OpaqueContT k r m) where
--   unit ‚à∑ a ‚Üí OpaqueContT k r m a
--   unit a = OpaqueContT  $ \ k ‚Üí runContFun (morph3 k) a
-- instance (Monad m, Isomorphism3 (ContFun r) (k r)) ‚áí Applicative (OpaqueContT k r m) where (<‚ãÖ>) = mapply
-- instance (Monad m, Isomorphism3 (ContFun r) (k r)) ‚áí Product (OpaqueContT k r m) where (<*>) = mpair
-- writerRWSCommute ‚à∑ (Monad m, Monoid o1, Monoid o2) ‚áí WriterT o1 (RWST r o2 s m) ‚Üù RWST r o2 s (WriterT o1 m)
-- writerRWSCommute =
--     RWST
--   ‚àò fmap 
--     ( fmap writerStateCommute
--     ‚àò writerCommute
--     )
--   ‚àò writerReaderCommute
--   ‚àò fmap unRWST
-- 
-- rwsWriterCommute ‚à∑ (Monad m, Monoid o1, Monoid o2) ‚áí RWST r o1 s (WriterT o2 m) ‚Üù WriterT o2 (RWST r o1 s m)
-- rwsWriterCommute =
--     fmap RWST
--   ‚àò readerWriterCommute
--   ‚àò fmap 
--     ( writerCommute
--     ‚àò fmap stateWriterCommute
--     )
--   ‚àò unRWST
-- stateRWSCommute ‚à∑ (Monad m, Monoid o) ‚áí StateT s1 (RWST r o s2 m) ‚Üù RWST r o s2 (StateT s1 m)
-- stateRWSCommute =
--     RWST
--   ‚àò fmap 
--     ( fmap stateCommute
--     ‚àò stateWriterCommute
--     )
--   ‚àò stateReaderCommute
--   ‚àò fmap unRWST
-- 
-- rwsStateCommute ‚à∑ (Monad m, Monoid o) ‚áí RWST r o s1 (StateT s2 m) ‚Üù StateT s2 (RWST r o s1 m)
-- rwsStateCommute =
--     fmap RWST
--   ‚àò readerStateCommute
--   ‚àò fmap 
--     ( writerStateCommute
--     ‚àò fmap stateCommute
--     )
--   ‚àò unRWST
-- class Commute (t ‚à∑ ‚òÖ ‚Üí ‚òÖ) (u ‚à∑ ‚òÖ ‚Üí ‚òÖ) where commute ‚à∑ t (u a) ‚Üí u (t a)
--
--
-- module FP.String where
-- 
-- import FP.Core
-- 
-- import Text.Regex.TDFA ((=~))
-- import qualified Data.Text.Encoding as Text
-- 
-- match :: String -> String -> (String, String, String)
-- match pat t = 
--   let (before, m, after) = Text.encodeUtf8 t =~ toChars pat 
--   in (Text.decodeUtf8 before, Text.decodeUtf8 m, Text.decodeUtf8 after)
-- 
-- matches :: String -> String -> Bool
-- matches pat t = Text.encodeUtf8 t =~ toChars pat
-- 
-- subst :: String -> String -> String -> String
-- subst pat replacement t =
--   let (before, m, after) = match pat t
--   in if m == "" then t else before ++ replacement ++ subst pat replacement after
--
--
--
-- module FP.Lattice where
-- 
-- import FP.Prelude
-- import FP.Pretty
-- 
-- -- data FreeJoinLattice a =
-- --     FreeJoinBot
-- --   | FreeJoinJoin (FreeJoinLattice a) (FreeJoinLattice a)
-- --   | FreeJoinLatticeElem a
-- -- 
-- -- instance ToStream a (FreeJoinLattice a) where 
-- --   stream ‚à∑ FreeJoinLattice a ‚Üí Stream a
-- --   stream FreeJoinBot = null
-- --   stream (FreeJoinJoin xs ys) = stream xs ‚ß∫ stream ys
-- --   stream (FreeJoinLatticeElem x) = ssingle x
-- -- 
-- -- instance Functor FreeJoinLattice where
-- --   map ‚à∑ (a ‚Üí b) ‚Üí FreeJoinLattice a ‚Üí FreeJoinLattice b
-- --   map _ FreeJoinBot = FreeJoinBot
-- --   map f (FreeJoinJoin xs ys) = FreeJoinJoin (map f xs) (map f ys)
-- --   map f (FreeJoinLatticeElem x) = FreeJoinLatticeElem $ f x
-- -- instance Monad FreeJoinLattice where
-- --   return ‚à∑ a ‚Üí FreeJoinLattice a
-- --   return = FreeJoinLatticeElem
-- --   (‚â´=) ‚à∑ FreeJoinLattice a ‚Üí (a ‚Üí FreeJoinLattice b) ‚Üí FreeJoinLattice b
-- --   FreeJoinBot ‚â´= _ = FreeJoinBot
-- --   FreeJoinJoin xs ys ‚â´= k = FreeJoinJoin (xs ‚â´= k) (ys ‚â´= k)
-- --   FreeJoinLatticeElem x ‚â´= k = k x
-- -- 
-- -- instance Bot (FreeJoinLattice a) where bot = FreeJoinBot
-- -- instance Join (FreeJoinLattice a) where (‚äî) = FreeJoinJoin
-- -- instance JoinLattice (FreeJoinLattice a)
-- -- 
-- -- newtype FreeJoinLatticeT m a = FreeJoinLatticeT { runFreeJoinLatticeT ‚à∑ m (FreeJoinLattice a) }
-- -- 
-- -- instance (Functor m) ‚áí Functor (FreeJoinLatticeT m) where
-- --   map ‚à∑ (a ‚Üí b) ‚Üí FreeJoinLatticeT m a ‚Üí FreeJoinLatticeT m b
-- --   map f = FreeJoinLatticeT ‚àò map (map f) ‚àò runFreeJoinLatticeT
-- -- instance
-- --   ( Monad m
-- --   , Functorial Bot m
-- --   , Functorial Join m
-- --   ) ‚áí Monad (FreeJoinLatticeT m) where
-- --   return ‚à∑ a ‚Üí FreeJoinLatticeT m a
-- --   return = FreeJoinLatticeT ‚àò return ‚àò FreeJoinLatticeElem
-- --   (‚â´=) ‚à∑ FreeJoinLatticeT m a ‚Üí (a ‚Üí FreeJoinLatticeT m b) ‚Üí FreeJoinLatticeT m b
-- --   xM ‚â´= k‚ÇÄ = FreeJoinLatticeT $ do
-- --     x ‚Üê runFreeJoinLatticeT xM 
-- --     runFreeJoinLatticeT $ loop x k‚ÇÄ
-- --     where
-- --       loop ‚à∑ FreeJoinLattice a ‚Üí (a ‚Üí FreeJoinLatticeT m b) ‚Üí FreeJoinLatticeT m b
-- --       loop FreeJoinBot _ = mbot
-- --       loop (FreeJoinJoin xs ys) k = loop xs k <‚äî> loop ys k
-- --       loop (FreeJoinLatticeElem x) k = k x
-- -- 
-- -- instance FunctorUnit FreeJoinLatticeT where
-- --   funit ‚à∑ (Functor m) ‚áí m ‚Üù FreeJoinLatticeT m
-- --   funit = FreeJoinLatticeT ‚àò map return
-- -- instance FunctorDiscard FreeJoinLatticeT where
-- --   fdiscard ‚à∑ (Functor m) ‚áí FreeJoinLatticeT (FreeJoinLatticeT m) ‚Üù FreeJoinLatticeT m
-- --   fdiscard = FreeJoinLatticeT ‚àò map joins ‚àò runFreeJoinLatticeT ‚àò runFreeJoinLatticeT
-- -- instance FunctorFunctor FreeJoinLatticeT where
-- --   fmap ‚à∑ (m ‚Üù n) ‚Üí FreeJoinLatticeT m ‚Üù FreeJoinLatticeT n
-- --   fmap f = FreeJoinLatticeT ‚àò f ‚àò runFreeJoinLatticeT
-- -- 
-- -- instance (Functorial Bot m) ‚áí MonadBot (FreeJoinLatticeT m) where
-- --   mbot ‚à∑ ‚àÄ a. FreeJoinLatticeT m a
-- --   mbot = with (functorial ‚à∑ W (Bot (m (FreeJoinLattice a)))) $
-- --     FreeJoinLatticeT bot
-- -- instance (Functorial Join m) ‚áí MonadJoin (FreeJoinLatticeT m) where
-- --   (<‚äî>) ‚à∑ ‚àÄ a. FreeJoinLatticeT m a ‚Üí FreeJoinLatticeT m a ‚Üí FreeJoinLatticeT m a
-- --   aM‚ÇÅ <‚äî> aM‚ÇÇ = with (functorial ‚à∑ W (Join (m (FreeJoinLattice a)))) $
-- --     FreeJoinLatticeT $ runFreeJoinLatticeT aM‚ÇÅ ‚äî runFreeJoinLatticeT aM‚ÇÇ
-- -- 
-- -- -- ## FreeJoinLattice // State
-- -- 
-- -- joinLatticeStateCommute ‚à∑ (Functor m) ‚áí FreeJoinLatticeT (StateT s m) ‚Üù StateT s (FreeJoinLatticeT m)
-- -- joinLatticeStateCommute aMM = StateT $ \ s ‚Üí FreeJoinLatticeT $ ff ^$ runStateTWith s $ runFreeJoinLatticeT aMM
-- --   where
-- --     ff ‚à∑ (s,FreeJoinLattice a) ‚Üí FreeJoinLattice (s,a)
-- --     ff (s,xs) = (s,) ^$ xs
-- -- 
-- -- stateJoinLatticeCommute ‚à∑ ‚àÄ s m. (Functor m, JoinLattice s) ‚áí StateT s (FreeJoinLatticeT m) ‚Üù FreeJoinLatticeT (StateT s m)
-- -- stateJoinLatticeCommute aMM = FreeJoinLatticeT $ StateT $ \ s ‚Üí ff ^$ runFreeJoinLatticeT $ runStateTWith s aMM
-- --   where
-- --     ff ‚à∑ FreeJoinLattice (s,a) ‚Üí (s,FreeJoinLattice a)
-- --     ff asL = (joins $ fst ^$ asL, snd ^$ asL)
-- -- 
-- -- instance (Functor m, MonadState s m, JoinLattice s) ‚áí MonadState s (FreeJoinLatticeT m) where
-- --   stateI ‚à∑ FreeJoinLatticeT m ‚Üù StateT s (FreeJoinLatticeT m)
-- --   stateI = joinLatticeStateCommute ‚àò fmap stateI
-- --   stateE ‚à∑ StateT s (FreeJoinLatticeT m) ‚Üù FreeJoinLatticeT m
-- --   stateE = fmap stateE ‚àò stateJoinLatticeCommute
-- -- 
-- -- -- FreeLattice
-- -- 
-- -- data FreeLattice a =
-- --     FreeBot
-- --   | FreeTop
-- --   | FreeJoin (FreeLattice a) (FreeLattice a)
-- --   | FreeMeet (FreeLattice a) (FreeLattice a)
-- --   | FreeLatticeElem a
-- -- 
-- -- joinsFreeLattice ‚à∑ FreeLattice (FreeLattice a) ‚Üí FreeLattice a
-- -- joinsFreeLattice FreeBot = FreeBot
-- -- joinsFreeLattice FreeTop = FreeTop
-- -- joinsFreeLattice (FreeJoin xs ys) = FreeJoin (joinsFreeLattice xs) (joinsFreeLattice ys)
-- -- joinsFreeLattice (FreeMeet xs ys) = FreeMeet (joinsFreeLattice xs) (joinsFreeLattice ys)
-- -- joinsFreeLattice (FreeLatticeElem xs) = xs
-- -- 
-- -- instance Functor FreeLattice where
-- --   map ‚à∑ (a ‚Üí b) ‚Üí FreeLattice a ‚Üí FreeLattice b
-- --   map _ FreeBot = FreeBot
-- --   map _ FreeTop = FreeTop
-- --   map f (FreeJoin xs ys) = FreeJoin (map f xs) (map f ys)
-- --   map f (FreeMeet xs ys) = FreeMeet (map f xs) (map f ys)
-- --   map f (FreeLatticeElem x) = FreeLatticeElem $ f x
-- -- instance Monad FreeLattice where
-- --   return ‚à∑ a ‚Üí FreeLattice a
-- --   return = FreeLatticeElem
-- --   (‚â´=) ‚à∑ FreeLattice a ‚Üí (a ‚Üí FreeLattice b) ‚Üí FreeLattice b
-- --   FreeBot ‚â´= _ = FreeBot
-- --   FreeTop ‚â´= _ = FreeTop
-- --   FreeJoin xs ys ‚â´= k = FreeJoin (xs ‚â´= k) (ys ‚â´= k)
-- --   FreeMeet xs ys ‚â´= k = FreeMeet (xs ‚â´= k) (ys ‚â´= k)
-- --   FreeLatticeElem x ‚â´= k = k x
-- -- 
-- -- instance Bot (FreeLattice a) where bot = FreeBot
-- -- instance Join (FreeLattice a) where (‚äî) = FreeJoin
-- -- instance JoinLattice (FreeLattice a)
-- -- instance Top (FreeLattice a) where top = FreeTop
-- -- instance Meet (FreeLattice a) where (‚äì) = FreeMeet
-- -- instance MeetLattice (FreeLattice a)
-- -- 
-- -- newtype FreeLatticeT m a = FreeLatticeT { runFreeLatticeT ‚à∑ m (FreeLattice a) }
-- -- 
-- -- instance (Functor m) ‚áí Functor (FreeLatticeT m) where
-- --   map ‚à∑ (a ‚Üí b) ‚Üí FreeLatticeT m a ‚Üí FreeLatticeT m b
-- --   map f = FreeLatticeT ‚àò map (map f) ‚àò runFreeLatticeT
-- -- instance 
-- --   ( Monad m
-- --   , Functorial Bot m
-- --   , Functorial Join m
-- --   , Functorial Top m
-- --   , Functorial Meet m
-- --   ) ‚áí Monad (FreeLatticeT m) where
-- --   return ‚à∑ a ‚Üí FreeLatticeT m a
-- --   return = FreeLatticeT ‚àò return ‚àò FreeLatticeElem
-- --   (‚â´=) ‚à∑ FreeLatticeT m a ‚Üí (a ‚Üí FreeLatticeT m b) ‚Üí FreeLatticeT m b
-- --   xM ‚â´= k‚ÇÄ = FreeLatticeT $ do
-- --     x ‚Üê runFreeLatticeT xM 
-- --     runFreeLatticeT $ loop x k‚ÇÄ
-- --     where
-- --       loop ‚à∑ FreeLattice a ‚Üí (a ‚Üí FreeLatticeT m b) ‚Üí FreeLatticeT m b
-- --       loop FreeBot _ = mbot
-- --       loop FreeTop _ = mtop
-- --       loop (FreeJoin xs ys) k = loop xs k <‚äî> loop ys k
-- --       loop (FreeMeet xs ys) k = loop xs k <‚äì> loop ys k
-- --       loop (FreeLatticeElem x) k = k x
-- -- 
-- -- instance FunctorUnit FreeLatticeT where
-- --   funit ‚à∑ (Functor m) ‚áí m ‚Üù FreeLatticeT m
-- --   funit = FreeLatticeT ‚àò map return
-- -- instance FunctorDiscard FreeLatticeT where
-- --   fdiscard ‚à∑ (Functor m) ‚áí FreeLatticeT (FreeLatticeT m) ‚Üù FreeLatticeT m
-- --   fdiscard = FreeLatticeT ‚àò map joinsFreeLattice ‚àò runFreeLatticeT ‚àò runFreeLatticeT
-- -- instance FunctorFunctor FreeLatticeT where
-- --   fmap ‚à∑ (m ‚Üù n) ‚Üí FreeLatticeT m ‚Üù FreeLatticeT n
-- --   fmap f = FreeLatticeT ‚àò f ‚àò runFreeLatticeT
-- -- 
-- -- instance (Functorial Bot m) ‚áí MonadBot (FreeLatticeT m) where
-- --   mbot ‚à∑ ‚àÄ a. FreeLatticeT m a
-- --   mbot = with (functorial ‚à∑ W (Bot (m (FreeLattice a)))) $
-- --     FreeLatticeT bot
-- -- instance (Functorial Join m) ‚áí MonadJoin (FreeLatticeT m) where
-- --   (<‚äî>) ‚à∑ ‚àÄ a. FreeLatticeT m a ‚Üí FreeLatticeT m a ‚Üí FreeLatticeT m a
-- --   aM‚ÇÅ <‚äî> aM‚ÇÇ = with (functorial ‚à∑ W (Join (m (FreeLattice a)))) $
-- --     FreeLatticeT $ runFreeLatticeT aM‚ÇÅ ‚äî runFreeLatticeT aM‚ÇÇ
-- -- instance (Functorial Top m) ‚áí MonadTop (FreeLatticeT m) where
-- --   mtop ‚à∑ ‚àÄ a. FreeLatticeT m a
-- --   mtop = with (functorial ‚à∑ W (Top (m (FreeLattice a)))) $
-- --     FreeLatticeT top
-- -- instance (Functorial Meet m) ‚áí MonadMeet (FreeLatticeT m) where
-- --   (<‚äì>) ‚à∑ ‚àÄ a. FreeLatticeT m a ‚Üí FreeLatticeT m a ‚Üí FreeLatticeT m a
-- --   aM‚ÇÅ <‚äì> aM‚ÇÇ = with (functorial ‚à∑ W (Meet (m (FreeLattice a)))) $
-- --     FreeLatticeT $ runFreeLatticeT aM‚ÇÅ ‚äì runFreeLatticeT aM‚ÇÇ
-- -- 
-- -- -- ## Lattice // State
-- -- 
-- -- latticeStateCommute ‚à∑ (Functor m) ‚áí FreeLatticeT (StateT s m) ‚Üù StateT s (FreeLatticeT m)
-- -- latticeStateCommute aMM = StateT $ \ s ‚Üí FreeLatticeT $ ff ^$ runStateTWith s $ runFreeLatticeT aMM
-- --   where
-- --     ff ‚à∑ (s,FreeLattice a) ‚Üí FreeLattice (s,a)
-- --     ff (s,xs) = (s,) ^$ xs
-- -- 
-- -- stateLatticeCommute ‚à∑ ‚àÄ s m. (Functor m, Lattice s) ‚áí StateT s (FreeLatticeT m) ‚Üù FreeLatticeT (StateT s m)
-- -- stateLatticeCommute aMM = FreeLatticeT $ StateT $ \ s ‚Üí ff ^$ runFreeLatticeT $ runStateTWith s aMM
-- --   where
-- --     ff ‚à∑ FreeLattice (s,a) ‚Üí (s,FreeLattice a)
-- --     ff FreeBot = (bot,bot)
-- --     ff FreeTop = (top,top)
-- --     ff (FreeJoin xs ys) = 
-- --       let (s‚ÇÅ,xs') = ff xs
-- --           (s‚ÇÇ,ys') = ff ys
-- --       in (s‚ÇÅ ‚äî s‚ÇÇ,FreeJoin xs' ys')
-- --     ff (FreeMeet xs ys) =
-- --       let (s‚ÇÅ,xs') = ff xs
-- --           (s‚ÇÇ,ys') = ff ys
-- --       in (s‚ÇÅ ‚äì s‚ÇÇ,FreeMeet xs' ys')
-- --     ff (FreeLatticeElem (s,x)) = (s,FreeLatticeElem x)
-- -- 
-- -- instance (Functor m, MonadState s m, Lattice s) ‚áí MonadState s (FreeLatticeT m) where
-- --   stateI ‚à∑ FreeLatticeT m ‚Üù StateT s (FreeLatticeT m)
-- --   stateI = latticeStateCommute ‚àò fmap stateI
-- --   stateE ‚à∑ StateT s (FreeLatticeT m) ‚Üù FreeLatticeT m
-- --   stateE = fmap stateE ‚àò stateLatticeCommute
-- -- 
-- -- -- # SetWithTop
-- -- 
-- -- data SetWithTop a = SetTop | SetNotTop (ùí´ a)
-- -- 
-- -- instance Bot (SetWithTop a) where bot = SetNotTop bot
-- -- instance Join (SetWithTop a) where
-- --   SetTop ‚äî _ = SetTop
-- --   _ ‚äî SetTop = SetTop
-- --   SetNotTop xs ‚äî SetNotTop ys = SetNotTop $ xs ‚äî ys
-- -- instance JoinLattice (SetWithTop a)
-- -- instance Top (SetWithTop a) where top = SetTop
-- -- instance Meet (SetWithTop a) where
-- --   SetTop ‚äì ys = ys
-- --   xs ‚äì SetTop = xs
-- --   SetNotTop xs ‚äì SetNotTop ys = SetNotTop $ xs ‚äì ys
-- -- instance MeetLattice (SetWithTop a)
-- -- instance Lattice (SetWithTop a)
-- -- 
-- -- -- (‚â´=*‚ä§) ‚à∑ SetWithTop a ‚Üí (a ‚Üí SetWithTop b) ‚Üí SetWithTop b
-- -- -- SetTop ‚â´=*‚ä§ _       = SetTop
-- -- -- SetNotTop xs ‚â´=*‚ä§ k = joins $ map k $ stream xs
-- -- 
-- -- -- # Constructive Classical
-- -- 
-- -- -- data ConstructiveClassical a = Constructive (ùí´ a) | Classical (a ‚Üí ùîπ)
-- -- -- 
-- -- -- conClaPartition ‚à∑ [ConstructiveClassical a] ‚Üí ([ùí´ a], [a ‚Üí ùîπ])
-- -- -- conClaPartition = iter ff ([], [])
-- -- --   where
-- -- --     ff (Constructive c) (cs, ps) = (c : cs, ps)
-- -- --     ff (Classical p) (cs, ps) = (cs, p : ps)
-- -- -- 
-- -- -- conClaBigProduct ‚à∑ ‚àÄ a. (Ord a) ‚áí [ConstructiveClassical a] ‚Üí SetWithTop a
-- -- -- conClaBigProduct xs = do
-- -- --   let (cs, ps) = conClaPartition xs
-- -- --       c ‚à∑ ùí´ a
-- -- --       c = meets $ map SetNotTop cs
-- -- --       p ‚à∑ a ‚Üí ùîπ
-- -- --       p = joins ps
-- -- --   case c of
-- -- --     SetTop ‚Üí if isL nilL ps then bot else top
-- -- --     SetNotTop candidates ‚Üí SetNotTop $
-- -- --       candidates ‚â´=* \ candidate ‚Üí
-- -- --       botGuard $ p candidate ‚â´=* \ _ ‚Üí
-- -- --       set $ single candidate
-- -- 
-- -- -- -- -- SumOfProd {{{
-- -- -- -- 
-- -- -- -- newtype SumOfProd a = SumOfProd { unSumOfProd ‚à∑ Set (Set a) }
-- -- -- --   deriving (Eq, Ord)
-- -- -- -- instance (Ord a) ‚áí Buildable a (SumOfProd a) where { nil = SumOfProd empty ; a & s = SumOfProd $ single (single a) ‚äî unSumOfProd s }
-- -- -- -- 
-- -- -- -- sumOfProdMap ‚à∑ (Ord b) ‚áí (a ‚Üí b) ‚Üí SumOfProd a ‚Üí SumOfProd b
-- -- -- -- sumOfProdMap f = SumOfProd . setMap (setMap f) . unSumOfProd
-- -- -- -- 
-- -- -- -- sumOfProdConcretize ‚à∑ (Ord b) ‚áí (a ‚Üí ConstructiveClassical b) ‚Üí SumOfProd a ‚Üí SetWithTop b
-- -- -- -- sumOfProdConcretize p v = setFromListWithTop $ conClaBigProduct *$ mlist $ map (map p . toList) $ toList $ unSumOfProd v
-- -- -- -- 
-- -- -- -- instance Bot (SumOfProd a) where bot = SumOfProd empty
-- -- -- -- instance Join (SumOfProd a) where sps1 ‚äî sps2 = SumOfProd $ unSumOfProd sps1 ‚äî unSumOfProd sps2
-- -- -- -- instance Meet (SumOfProd a) where
-- -- -- --   sps‚ÇÅ /\ sps‚ÇÇ = SumOfProd $ do
-- -- -- --     ps‚ÇÅ ‚Üê unSumOfProd sps‚ÇÅ
-- -- -- --     ps‚ÇÇ ‚Üê unSumOfProd sps‚ÇÇ
-- -- -- --     single $ ps‚ÇÅ ‚äî ps‚ÇÇ
-- -- -- -- instance (Ord a, Neg a) ‚áí Neg (SumOfProd a) where neg = sumOfProdMap neg . SumOfProd . setBigProduct . unSumOfProd
-- -- -- -- instance JoinLattice (SumOfProd a)
-- -- -- -- 
-- -- -- -- -- }}}
